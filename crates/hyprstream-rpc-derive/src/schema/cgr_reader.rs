//! CGR-based Cap'n Proto schema parser.
//!
//! Reads binary CodeGeneratorRequest (CGR) files produced by `capnp compile`
//! via build.rs, and produces the same `ParsedSchema` as the text parser.
//!
//! Advantages over text parsing:
//! - Full type resolution (struct names resolved via node graph)
//! - Native annotation extraction (no text stripping hacks)
//! - Deterministic output (BTreeMap for node ordering)
//! - No fragile brace matching or comment handling
//! - Discriminant values available directly

use std::collections::BTreeMap;
use std::path::Path;

use super::types::*;
use crate::util::{to_pascal_case, to_snake_case};

/// Parse a schema from a CGR binary file in OUT_DIR.
///
/// The CGR file is generated by build.rs via `capnpc::CompilerCommand::raw_code_generator_request_path()`.
pub fn parse_from_cgr(name: &str) -> Result<ParsedSchema, String> {
    let out_dir = std::env::var("OUT_DIR")
        .map_err(|_| "OUT_DIR not set — CGR files require build.rs to run first".to_owned())?;
    let cgr_path = Path::new(&out_dir).join(format!("{name}.cgr"));

    let file = std::fs::File::open(&cgr_path)
        .map_err(|e| format!("Failed to open {}: {e}", cgr_path.display()))?;

    let reader = capnp::serialize::read_message(
        std::io::BufReader::new(file),
        capnp::message::ReaderOptions::new(),
    )
    .map_err(|e| format!("Failed to read CGR for '{name}': {e}"))?;

    let cgr = reader
        .get_root::<capnp::schema_capnp::code_generator_request::Reader>()
        .map_err(|e| format!("Failed to parse CGR root for '{name}': {e}"))?;

    parse_cgr(cgr, name)
}

// ─────────────────────────────────────────────────────────────────────────────
// Internal: CGR parsing
// ─────────────────────────────────────────────────────────────────────────────

/// A resolved node from the CGR node graph.
struct NodeInfo {
    id: u64,
    display_name: String,
    /// Short name extracted from display_name (after last ':')
    short_name: String,
    /// Index into the CGR nodes list (for re-reading)
    index: u32,
    /// Parent node ID (scope_id)
    #[allow(dead_code)]
    parent_id: u64,
}

/// Parse the CodeGeneratorRequest into a ParsedSchema.
fn parse_cgr(
    cgr: capnp::schema_capnp::code_generator_request::Reader,
    service_name: &str,
) -> Result<ParsedSchema, String> {
    let nodes = cgr.get_nodes().map_err(|e| format!("{e}"))?;

    // Build node map: id → NodeInfo (BTreeMap for deterministic iteration)
    let mut node_map: BTreeMap<u64, NodeInfo> = BTreeMap::new();
    for i in 0..nodes.len() {
        let node = nodes.get(i);
        let display_name = node
            .get_display_name()
            .map_err(|e| format!("{e}"))?
            .to_str()
            .map_err(|e| format!("{e}"))?.to_owned();
        let short_name = display_name
            .rsplit(':')
            .next()
            .unwrap_or(&display_name).to_owned();
        node_map.insert(
            node.get_id(),
            NodeInfo {
                id: node.get_id(),
                display_name,
                short_name,
                index: i,
                parent_id: node.get_scope_id(),
            },
        );
    }

    // Find annotation node IDs by display_name (for mcpDescription, paramDescription, mcpScope, cliHidden, domainType)
    let mcp_desc_id = find_annotation_id(&nodes, &node_map, "mcpDescription");
    let param_desc_id = find_annotation_id(&nodes, &node_map, "paramDescription");
    let mcp_scope_id = find_annotation_id(&nodes, &node_map, "mcpScope");
    let cli_hidden_id = find_annotation_id(&nodes, &node_map, "cliHidden");
    let domain_type_id = find_annotation_id(&nodes, &node_map, "domainType");
    let fixed_size_id = find_annotation_id(&nodes, &node_map, "fixedSize");
    let optional_id = find_annotation_id(&nodes, &node_map, "optional");

    let pascal = to_pascal_case(service_name);
    let request_name = format!("{pascal}Request");
    let response_name = format!("{pascal}Response");

    // Find request and response struct node IDs
    let request_node_id = find_struct_node_id(&node_map, &request_name)
        .ok_or_else(|| format!("Struct '{request_name}' not found in CGR"))?;
    let response_node_id = find_struct_node_id(&node_map, &response_name)
        .ok_or_else(|| format!("Struct '{response_name}' not found in CGR"))?;

    let request_node = nodes.get(node_map[&request_node_id].index);
    let response_node = nodes.get(node_map[&response_node_id].index);

    // Extract union variants from request/response
    let request_variants = extract_union_variants(
        request_node,
        &nodes,
        &node_map,
        mcp_desc_id,
        param_desc_id,
        mcp_scope_id,
        cli_hidden_id,
    )?;
    let response_variants = extract_union_variants(
        response_node,
        &nodes,
        &node_map,
        mcp_desc_id,
        param_desc_id,
        mcp_scope_id,
        cli_hidden_id,
    )?;

    if request_variants.is_empty() || response_variants.is_empty() {
        return Err(format!(
            "Schema '{service_name}' has empty request or response union"
        ));
    }

    // Extract all structs (for type resolution in codegen)
    let all_structs = extract_all_structs(
        &nodes,
        &node_map,
        service_name,
        mcp_desc_id,
        param_desc_id,
        domain_type_id,
        fixed_size_id,
        optional_id,
    )?;

    // Extract all enums (pass all_structs for imported type resolution)
    let enums = extract_all_enums(&nodes, &node_map, service_name, &all_structs)?;

    // Detect scoped clients (nested union pattern)
    let mut scoped_clients = detect_scoped_clients(
        &request_variants,
        &response_variants,
        &all_structs,
        &nodes,
        &node_map,
        mcp_desc_id,
        param_desc_id,
        mcp_scope_id,
        cli_hidden_id,
    )?;

    // Recursively detect nested scoped clients (3rd level)
    for sc in &mut scoped_clients {
        detect_nested_scoped_clients_cgr(
            sc,
            &all_structs,
            &nodes,
            &node_map,
            mcp_desc_id,
            param_desc_id,
            mcp_scope_id,
            cli_hidden_id,
        )?;
    }

    // Filter out request/response structs from the referenced structs
    let referenced: Vec<StructDef> = all_structs
        .into_iter()
        .filter(|s| s.name != request_name && s.name != response_name)
        .collect();

    Ok(ParsedSchema {
        request_variants,
        response_variants,
        structs: referenced,
        scoped_clients,
        enums,
    })
}

// ─────────────────────────────────────────────────────────────────────────────
// Node lookup helpers
// ─────────────────────────────────────────────────────────────────────────────

/// Find a struct node ID by short name.
fn find_struct_node_id(node_map: &BTreeMap<u64, NodeInfo>, short_name: &str) -> Option<u64> {
    node_map
        .values()
        .find(|n| n.short_name == short_name)
        .map(|n| n.id)
}

/// Find an annotation node ID by its short name (e.g., "mcpDescription").
fn find_annotation_id(
    nodes: &capnp::struct_list::Reader<capnp::schema_capnp::node::Owned>,
    node_map: &BTreeMap<u64, NodeInfo>,
    annotation_name: &str,
) -> Option<u64> {
    for info in node_map.values() {
        let node = nodes.get(info.index);
        if let Ok(capnp::schema_capnp::node::Annotation(_)) = node.which() {
            if info.short_name == annotation_name {
                return Some(info.id);
            }
        }
    }
    None
}

/// Resolve a type ID to a short struct/enum name using the node map.
fn resolve_type_name(
    type_reader: capnp::schema_capnp::type_::Reader,
    node_map: &BTreeMap<u64, NodeInfo>,
) -> String {
    use capnp::schema_capnp::type_;
    match type_reader.which() {
        Ok(type_::Void(())) => "Void".into(),
        Ok(type_::Bool(())) => "Bool".into(),
        Ok(type_::Int8(())) => "Int8".into(),
        Ok(type_::Int16(())) => "Int16".into(),
        Ok(type_::Int32(())) => "Int32".into(),
        Ok(type_::Int64(())) => "Int64".into(),
        Ok(type_::Uint8(())) => "UInt8".into(),
        Ok(type_::Uint16(())) => "UInt16".into(),
        Ok(type_::Uint32(())) => "UInt32".into(),
        Ok(type_::Uint64(())) => "UInt64".into(),
        Ok(type_::Float32(())) => "Float32".into(),
        Ok(type_::Float64(())) => "Float64".into(),
        Ok(type_::Text(())) => "Text".into(),
        Ok(type_::Data(())) => "Data".into(),
        Ok(type_::List(list_type)) => {
            if let Ok(element_type) = list_type.get_element_type() {
                format!("List({})", resolve_type_name(element_type, node_map))
            } else {
                "List".into()
            }
        }
        Ok(type_::Enum(enum_type)) => {
            let type_id = enum_type.get_type_id();
            node_map
                .get(&type_id)
                .map(|n| n.short_name.clone())
                .unwrap_or_else(|| "Enum".into())
        }
        Ok(type_::Struct(struct_type)) => {
            let type_id = struct_type.get_type_id();
            node_map
                .get(&type_id)
                .map(|n| n.short_name.clone())
                .unwrap_or_else(|| "Struct".into())
        }
        Ok(type_::Interface(_)) => "Interface".into(),
        Ok(type_::AnyPointer(_)) => "AnyPointer".into(),
        Err(_) => "Unknown".into(),
    }
}

/// Extract text from an annotation value.
fn extract_annotation_text(
    annotations: capnp::struct_list::Reader<capnp::schema_capnp::annotation::Owned>,
    target_id: Option<u64>,
) -> String {
    let target_id = match target_id {
        Some(id) => id,
        None => return String::new(),
    };
    for i in 0..annotations.len() {
        let ann = annotations.get(i);
        if ann.get_id() == target_id {
            if let Ok(value) = ann.get_value() {
                if let Ok(capnp::schema_capnp::value::Text(Ok(text))) = value.which() {
                    if let Ok(s) = text.to_str() {
                        return s.to_owned();
                    }
                }
            }
        }
    }
    String::new()
}

/// Extract a UInt32 annotation value (e.g., `$fixedSize(32)`).
fn extract_annotation_u32(
    annotations: capnp::struct_list::Reader<capnp::schema_capnp::annotation::Owned>,
    target_id: Option<u64>,
) -> Option<u32> {
    let target_id = target_id?;
    for i in 0..annotations.len() {
        let ann = annotations.get(i);
        if ann.get_id() == target_id {
            if let Ok(value) = ann.get_value() {
                if let Ok(capnp::schema_capnp::value::Uint32(n)) = value.which() {
                    return Some(n);
                }
            }
        }
    }
    None
}

/// Extract an enum annotation value by resolving the ordinal to a variant name.
///
/// For `$mcpScope(write)`, the CGR stores `value::Enum(ordinal)`. We resolve
/// the annotation's declaration node to find its type (the ScopeAction enum),
/// then look up the enumerant name by ordinal.
fn extract_annotation_enum(
    annotations: capnp::struct_list::Reader<capnp::schema_capnp::annotation::Owned>,
    target_id: Option<u64>,
    nodes: &capnp::struct_list::Reader<capnp::schema_capnp::node::Owned>,
    node_map: &BTreeMap<u64, NodeInfo>,
) -> String {
    let target_id = match target_id {
        Some(id) => id,
        None => return String::new(),
    };
    for i in 0..annotations.len() {
        let ann = annotations.get(i);
        if ann.get_id() == target_id {
            if let Ok(value) = ann.get_value() {
                if let Ok(capnp::schema_capnp::value::Enum(ordinal)) = value.which() {
                    // Resolve the annotation declaration node to get the enum type
                    if let Some(ann_info) = node_map.get(&target_id) {
                        let ann_node = nodes.get(ann_info.index);
                        if let Ok(capnp::schema_capnp::node::Annotation(ann_reader)) = ann_node.which() {
                            if let Ok(type_reader) = ann_reader.get_type() {
                                if let Ok(capnp::schema_capnp::type_::Enum(enum_type)) = type_reader.which() {
                                    let enum_type_id = enum_type.get_type_id();
                                    if let Some(enum_info) = node_map.get(&enum_type_id) {
                                        let enum_node = nodes.get(enum_info.index);
                                        if let Ok(capnp::schema_capnp::node::Enum(enum_reader)) = enum_node.which() {
                                            if let Ok(enumerants) = enum_reader.get_enumerants() {
                                                // Find enumerant matching ordinal
                                                for j in 0..enumerants.len() {
                                                    let enumerant = enumerants.get(j);
                                                    if enumerant.get_code_order() == ordinal {
                                                        if let Ok(name) = enumerant.get_name() {
                                                            if let Ok(s) = name.to_str() {
                                                                return s.to_owned();
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                // Fallback: also try Text for backward compatibility
                if let Ok(capnp::schema_capnp::value::Text(Ok(text))) = value.which() {
                    if let Ok(s) = text.to_str() {
                        return s.to_owned();
                    }
                }
            }
        }
    }
    String::new()
}

/// Check if a Void annotation is present (e.g., $cliHidden).
fn has_annotation(
    annotations: capnp::struct_list::Reader<capnp::schema_capnp::annotation::Owned>,
    target_id: Option<u64>,
) -> bool {
    let target_id = match target_id {
        Some(id) => id,
        None => return false,
    };
    for i in 0..annotations.len() {
        if annotations.get(i).get_id() == target_id {
            return true;
        }
    }
    false
}

// ─────────────────────────────────────────────────────────────────────────────
// Union variant extraction
// ─────────────────────────────────────────────────────────────────────────────

/// Extract union variants from a struct node.
///
/// Union fields have discriminant != 0xFFFF.
fn extract_union_variants(
    struct_node: capnp::schema_capnp::node::Reader,
    nodes: &capnp::struct_list::Reader<capnp::schema_capnp::node::Owned>,
    node_map: &BTreeMap<u64, NodeInfo>,
    mcp_desc_id: Option<u64>,
    _param_desc_id: Option<u64>,
    mcp_scope_id: Option<u64>,
    cli_hidden_id: Option<u64>,
) -> Result<Vec<UnionVariant>, String> {
    let struct_reader = match struct_node.which() {
        Ok(capnp::schema_capnp::node::Struct(s)) => s,
        _ => return Ok(Vec::new()),
    };

    let fields = struct_reader.get_fields().map_err(|e| format!("{e}"))?;
    let mut variants = Vec::new();

    // Collect union fields (discriminant != 0xFFFF), sorted by discriminant for determinism
    let mut union_fields: Vec<(u16, u32)> = Vec::new();
    for i in 0..fields.len() {
        let field = fields.get(i);
        let disc = field.get_discriminant_value();
        if disc != 0xFFFF {
            union_fields.push((disc, i));
        }
    }
    union_fields.sort_by_key(|(disc, _)| *disc);

    for (_disc, idx) in union_fields {
        let field = fields.get(idx);
        let name = field
            .get_name()
            .map_err(|e| format!("{e}"))?
            .to_str()
            .map_err(|e| format!("{e}"))?.to_owned();

        let type_name = match field.which() {
            Ok(capnp::schema_capnp::field::Slot(slot)) => {
                let type_reader = slot.get_type().map_err(|e| format!("{e}"))?;
                resolve_type_name(type_reader, node_map)
            }
            Ok(capnp::schema_capnp::field::Group(_)) => "Group".into(),
            Err(e) => return Err(format!("Field error: {e}")),
        };

        let annotations = field.get_annotations().map_err(|e| format!("{e}"))?;
        let description = extract_annotation_text(annotations, mcp_desc_id);
        let scope = extract_annotation_enum(
            field.get_annotations().map_err(|e| format!("{e}"))?,
            mcp_scope_id,
            nodes,
            node_map,
        );
        let cli_hidden = has_annotation(
            field.get_annotations().map_err(|e| format!("{e}"))?,
            cli_hidden_id,
        );

        variants.push(UnionVariant {
            name,
            type_name,
            description,
            scope,
            cli_hidden,
        });
    }

    Ok(variants)
}

// ─────────────────────────────────────────────────────────────────────────────
// Struct extraction
// ─────────────────────────────────────────────────────────────────────────────

/// Extract a single struct definition from a CGR node.
#[allow(clippy::too_many_arguments)]
fn extract_struct_from_node(
    node: capnp::schema_capnp::node::Reader,
    info: &NodeInfo,
    node_map: &BTreeMap<u64, NodeInfo>,
    mcp_desc_id: Option<u64>,
    param_desc_id: Option<u64>,
    domain_type_id: Option<u64>,
    fixed_size_id: Option<u64>,
    optional_id: Option<u64>,
    origin_file: Option<String>,
) -> Result<Option<StructDef>, String> {
    let struct_reader = match node.which() {
        Ok(capnp::schema_capnp::node::Struct(s)) => s,
        _ => return Ok(None),
    };

    let domain_type = {
        let annotations = node.get_annotations().map_err(|e| format!("{e}"))?;
        let dt = extract_annotation_text(annotations, domain_type_id);
        if dt.is_empty() { None } else { Some(dt) }
    };

    let fields_reader = struct_reader.get_fields().map_err(|e| format!("{e}"))?;
    let mut fields = Vec::new();
    let mut has_union = false;

    for j in 0..fields_reader.len() {
        let field = fields_reader.get(j);
        let disc = field.get_discriminant_value();

        if disc != 0xFFFF {
            has_union = true;
            continue;
        }

        let field_name = field
            .get_name()
            .map_err(|e| format!("{e}"))?
            .to_str()
            .map_err(|e| format!("{e}"))?.to_owned();

        let type_name = match field.which() {
            Ok(capnp::schema_capnp::field::Slot(slot)) => {
                let type_reader = slot.get_type().map_err(|e| format!("{e}"))?;
                resolve_type_name(type_reader, node_map)
            }
            Ok(capnp::schema_capnp::field::Group(_)) => "Group".into(),
            Err(e) => return Err(format!("Field error: {e}")),
        };

        let description = {
            let annotations = field.get_annotations().map_err(|e| format!("{e}"))?;
            let desc = extract_annotation_text(annotations, param_desc_id);
            if desc.is_empty() {
                extract_annotation_text(
                    field.get_annotations().map_err(|e| format!("{e}"))?,
                    mcp_desc_id,
                )
            } else {
                desc
            }
        };

        let fixed_size = extract_annotation_u32(
            field.get_annotations().map_err(|e| format!("{e}"))?,
            fixed_size_id,
        );

        let optional = has_annotation(
            field.get_annotations().map_err(|e| format!("{e}"))?,
            optional_id,
        );

        fields.push(FieldDef {
            name: field_name,
            type_name,
            description,
            fixed_size,
            optional,
        });
    }

    if struct_reader.get_discriminant_count() > 0 {
        has_union = true;
    }

    Ok(Some(StructDef {
        name: info.short_name.clone(),
        fields,
        has_union,
        domain_type,
        origin_file,
    }))
}

/// Extract all struct definitions from the schema (for the given service file).
///
/// Two-pass extraction:
/// 1. First pass: extract local types from this schema file
/// 2. Second pass: find imported types referenced by variants/fields but not in the local set
#[allow(clippy::too_many_arguments)]
fn extract_all_structs(
    nodes: &capnp::struct_list::Reader<capnp::schema_capnp::node::Owned>,
    node_map: &BTreeMap<u64, NodeInfo>,
    service_name: &str,
    mcp_desc_id: Option<u64>,
    param_desc_id: Option<u64>,
    domain_type_id: Option<u64>,
    fixed_size_id: Option<u64>,
    optional_id: Option<u64>,
) -> Result<Vec<StructDef>, String> {
    let file_prefix = format!("{service_name}.capnp:");
    let mut structs = Vec::new();

    // Pass 1: extract local types
    for info in node_map.values() {
        if !info.display_name.starts_with(&file_prefix) {
            continue;
        }

        let node = nodes.get(info.index);
        if let Some(s) = extract_struct_from_node(
            node, info, node_map, mcp_desc_id, param_desc_id, domain_type_id, fixed_size_id, optional_id, None,
        )? {
            structs.push(s);
        }
    }

    // Pass 2: find imported structs referenced by local types but not yet extracted.
    // Collect type names from non-union fields of extracted structs...
    let local_names: std::collections::HashSet<String> =
        structs.iter().map(|s| s.name.clone()).collect();
    let mut referenced_names: std::collections::HashSet<String> = std::collections::HashSet::new();
    for s in &structs {
        for f in &s.fields {
            collect_type_refs(&f.type_name, &mut referenced_names);
        }
    }

    // ...AND from union variant types of all local struct CGR nodes.
    // extract_struct_from_node only captures non-union fields, so union variant
    // type references (e.g., `generateStreamResult @4 :StreamInfo`) are missed.
    // Scan the raw CGR to pick them up.
    for info in node_map.values() {
        if !info.display_name.starts_with(&file_prefix) {
            continue;
        }
        let node = nodes.get(info.index);
        if let Ok(capnp::schema_capnp::node::Struct(s)) = node.which() {
            if let Ok(fields) = s.get_fields() {
                for i in 0..fields.len() {
                    let field = fields.get(i);
                    if field.get_discriminant_value() != 0xFFFF {
                        // Union field — resolve its type reference
                        if let Ok(capnp::schema_capnp::field::Slot(slot)) = field.which() {
                            if let Ok(type_reader) = slot.get_type() {
                                let type_name = resolve_type_name(type_reader, node_map);
                                collect_type_refs(&type_name, &mut referenced_names);
                            }
                        }
                    }
                }
            }
        }
    }

    // For each referenced type not in the local set, look it up in node_map
    for ref_name in &referenced_names {
        if local_names.contains(ref_name) || is_primitive_type(ref_name) {
            continue;
        }
        // Find the node by short_name
        if let Some(info) = node_map.values().find(|n| n.short_name == *ref_name) {
            // Only extract if it's from a different file
            if !info.display_name.starts_with(&file_prefix) {
                let origin = extract_file_stem(&info.display_name);
                let node = nodes.get(info.index);
                if let Some(s) = extract_struct_from_node(
                    node, info, node_map, mcp_desc_id, param_desc_id, domain_type_id,
                    fixed_size_id, optional_id, Some(origin),
                )? {
                    structs.push(s);
                }
            }
        }
    }

    Ok(structs)
}

/// Extract file stem from a CGR display_name (e.g., "streaming.capnp:StreamInfo" → "streaming").
fn extract_file_stem(display_name: &str) -> String {
    display_name
        .split(':')
        .next()
        .unwrap_or("")
        .strip_suffix(".capnp")
        .unwrap_or("").to_owned()
}

/// Collect struct/enum type references from a capnp type name string.
fn collect_type_refs(type_name: &str, refs: &mut std::collections::HashSet<String>) {
    if let Some(inner) = type_name.strip_prefix("List(").and_then(|s| s.strip_suffix(')')) {
        collect_type_refs(inner, refs);
    } else if !is_primitive_type(type_name) {
        refs.insert(type_name.to_owned());
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Enum extraction
// ─────────────────────────────────────────────────────────────────────────────

/// Extract a single enum definition from a CGR node.
fn extract_enum_from_node(
    node: capnp::schema_capnp::node::Reader,
    info: &NodeInfo,
    origin_file: Option<String>,
) -> Result<Option<EnumDef>, String> {
    let enum_reader = match node.which() {
        Ok(capnp::schema_capnp::node::Enum(e)) => e,
        _ => return Ok(None),
    };

    let enumerants = enum_reader.get_enumerants().map_err(|e| format!("{e}"))?;
    let mut variants = Vec::new();

    for j in 0..enumerants.len() {
        let enumerant = enumerants.get(j);
        let variant_name = enumerant
            .get_name()
            .map_err(|e| format!("{e}"))?
            .to_str()
            .map_err(|e| format!("{e}"))?.to_owned();
        let code_order = enumerant.get_code_order() as u32;
        variants.push((variant_name, code_order));
    }

    Ok(Some(EnumDef {
        name: info.short_name.clone(),
        variants,
        origin_file,
    }))
}

/// Extract all enum definitions from the schema.
///
/// Two-pass extraction (same strategy as extract_all_structs):
/// 1. Local enums from this schema file
/// 2. Imported enums referenced by local struct fields
fn extract_all_enums(
    nodes: &capnp::struct_list::Reader<capnp::schema_capnp::node::Owned>,
    node_map: &BTreeMap<u64, NodeInfo>,
    service_name: &str,
    all_structs: &[StructDef],
) -> Result<Vec<EnumDef>, String> {
    let file_prefix = format!("{service_name}.capnp:");
    let mut enums = Vec::new();

    // Pass 1: local enums
    for info in node_map.values() {
        if !info.display_name.starts_with(&file_prefix) {
            continue;
        }

        let node = nodes.get(info.index);
        if let Some(e) = extract_enum_from_node(node, info, None)? {
            enums.push(e);
        }
    }

    // Pass 2: imported enums referenced by local struct fields
    let local_enum_names: std::collections::HashSet<String> =
        enums.iter().map(|e| e.name.clone()).collect();
    let local_struct_names: std::collections::HashSet<String> =
        all_structs.iter().map(|s| s.name.clone()).collect();

    let mut referenced_names: std::collections::HashSet<String> = std::collections::HashSet::new();
    for s in all_structs {
        for f in &s.fields {
            collect_type_refs(&f.type_name, &mut referenced_names);
        }
    }

    for ref_name in &referenced_names {
        if local_enum_names.contains(ref_name) || local_struct_names.contains(ref_name) || is_primitive_type(ref_name) {
            continue;
        }
        if let Some(info) = node_map.values().find(|n| n.short_name == *ref_name) {
            if !info.display_name.starts_with(&file_prefix) {
                let origin = extract_file_stem(&info.display_name);
                let node = nodes.get(info.index);
                if let Some(e) = extract_enum_from_node(node, info, Some(origin))? {
                    enums.push(e);
                }
            }
        }
    }

    Ok(enums)
}

// ─────────────────────────────────────────────────────────────────────────────
// Scoped client detection
// ─────────────────────────────────────────────────────────────────────────────

/// Detect scoped clients from the request/response pattern.
///
/// A scoped client is detected when:
/// - A request variant points to a struct with both non-union fields (scope) and a union
/// - A corresponding `{name}Result` response variant exists
#[allow(clippy::too_many_arguments)]
fn detect_scoped_clients(
    request_variants: &[UnionVariant],
    response_variants: &[UnionVariant],
    all_structs: &[StructDef],
    nodes: &capnp::struct_list::Reader<capnp::schema_capnp::node::Owned>,
    node_map: &BTreeMap<u64, NodeInfo>,
    mcp_desc_id: Option<u64>,
    param_desc_id: Option<u64>,
    mcp_scope_id: Option<u64>,
    cli_hidden_id: Option<u64>,
) -> Result<Vec<ScopedClient>, String> {
    let mut scoped = Vec::new();

    for req_variant in request_variants {
        // Skip primitives
        if is_primitive_type(&req_variant.type_name) {
            continue;
        }

        // Find the struct this variant points to
        let inner_struct = match all_structs.iter().find(|s| s.name == req_variant.type_name) {
            Some(s) => s,
            None => continue,
        };

        // Scoped client pattern: struct has union (with or without scope fields).
        // Union-only structs (no scope fields) produce scoped clients with empty scope_fields,
        // used for resource-oriented dispatch (e.g., worker sandbox/container/image scopes).
        if !inner_struct.has_union {
            continue;
        }

        // Find corresponding response variant
        let resp_variant_name = format!("{}Result", req_variant.name);
        let resp_variant = match response_variants
            .iter()
            .find(|v| v.name == resp_variant_name)
        {
            Some(v) => v,
            None => continue,
        };

        // Extract inner union variants from the request struct
        let inner_node_id = match find_struct_node_id(node_map, &req_variant.type_name) {
            Some(id) => id,
            None => continue,
        };
        let inner_node = nodes.get(node_map[&inner_node_id].index);
        let inner_req_variants =
            extract_union_variants(inner_node, nodes, node_map, mcp_desc_id, param_desc_id, mcp_scope_id, cli_hidden_id)?;

        // Extract inner union variants from the response struct
        let resp_node_id = match find_struct_node_id(node_map, &resp_variant.type_name) {
            Some(id) => id,
            None => continue,
        };
        let resp_node = nodes.get(node_map[&resp_node_id].index);
        let inner_resp_variants =
            extract_union_variants(resp_node, nodes, node_map, mcp_desc_id, param_desc_id, mcp_scope_id, cli_hidden_id)?;

        if inner_req_variants.is_empty() || inner_resp_variants.is_empty() {
            continue;
        }

        let client_name = if req_variant.type_name.ends_with("Request") {
            format!(
                "{}Client",
                &req_variant.type_name[..req_variant.type_name.len() - 7]
            )
        } else {
            format!("{}Client", req_variant.type_name)
        };

        scoped.push(ScopedClient {
            factory_name: req_variant.name.clone(),
            client_name,
            scope_fields: inner_struct.fields.clone(),
            inner_request_variants: inner_req_variants,
            inner_response_variants: inner_resp_variants,
            capnp_inner_response: to_snake_case(&resp_variant.type_name),
            nested_clients: Vec::new(),
        });
    }

    Ok(scoped)
}

/// Recursively detect nested scoped clients within a scoped client.
#[allow(clippy::too_many_arguments)]
fn detect_nested_scoped_clients_cgr(
    parent: &mut ScopedClient,
    all_structs: &[StructDef],
    nodes: &capnp::struct_list::Reader<capnp::schema_capnp::node::Owned>,
    node_map: &BTreeMap<u64, NodeInfo>,
    mcp_desc_id: Option<u64>,
    param_desc_id: Option<u64>,
    mcp_scope_id: Option<u64>,
    cli_hidden_id: Option<u64>,
) -> Result<(), String> {
    let mut nested = Vec::new();
    let mut nested_factory_names = Vec::new();

    for req_variant in &parent.inner_request_variants {
        if is_primitive_type(&req_variant.type_name) {
            continue;
        }

        let inner_struct = match all_structs.iter().find(|s| s.name == req_variant.type_name) {
            Some(s) => s,
            None => continue,
        };

        if !inner_struct.has_union || inner_struct.fields.is_empty() {
            continue;
        }

        let resp_variant_name = format!("{}Result", req_variant.name);
        let resp_variant = match parent
            .inner_response_variants
            .iter()
            .find(|v| v.name == resp_variant_name)
        {
            Some(v) => v,
            None => continue,
        };

        let inner_node_id = match find_struct_node_id(node_map, &req_variant.type_name) {
            Some(id) => id,
            None => continue,
        };
        let inner_node = nodes.get(node_map[&inner_node_id].index);
        let inner_req_variants =
            extract_union_variants(inner_node, nodes, node_map, mcp_desc_id, param_desc_id, mcp_scope_id, cli_hidden_id)?;

        let resp_node_id = match find_struct_node_id(node_map, &resp_variant.type_name) {
            Some(id) => id,
            None => continue,
        };
        let resp_node = nodes.get(node_map[&resp_node_id].index);
        let inner_resp_variants =
            extract_union_variants(resp_node, nodes, node_map, mcp_desc_id, param_desc_id, mcp_scope_id, cli_hidden_id)?;

        if inner_req_variants.is_empty() || inner_resp_variants.is_empty() {
            continue;
        }

        let client_name = if req_variant.type_name.ends_with("Request") {
            format!(
                "{}Client",
                &req_variant.type_name[..req_variant.type_name.len() - 7]
            )
        } else {
            format!("{}Client", req_variant.type_name)
        };

        nested_factory_names.push(req_variant.name.clone());
        nested.push(ScopedClient {
            factory_name: req_variant.name.clone(),
            client_name,
            scope_fields: inner_struct.fields.clone(),
            inner_request_variants: inner_req_variants,
            inner_response_variants: inner_resp_variants,
            capnp_inner_response: to_snake_case(&resp_variant.type_name),
            nested_clients: Vec::new(),
        });
    }

    // Filter out nested-scope variants from parent's inner variants
    if !nested_factory_names.is_empty() {
        parent
            .inner_request_variants
            .retain(|v| !nested_factory_names.contains(&v.name));
        parent.inner_response_variants.retain(|v| {
            let result_name = v.name.strip_suffix("Result").unwrap_or(&v.name);
            !nested_factory_names.contains(&result_name.to_owned())
        });
    }

    parent.nested_clients = nested;

    // Recurse into newly detected nested clients for deeper nesting
    for nested_client in &mut parent.nested_clients {
        detect_nested_scoped_clients_cgr(
            nested_client,
            all_structs,
            nodes,
            node_map,
            mcp_desc_id,
            param_desc_id,
            mcp_scope_id,
            cli_hidden_id,
        )?;
    }

    Ok(())
}

/// Check if a type name is a primitive (not a struct reference).
fn is_primitive_type(type_name: &str) -> bool {
    matches!(
        type_name,
        "Void"
            | "Text"
            | "Data"
            | "Bool"
            | "UInt8"
            | "UInt16"
            | "UInt32"
            | "UInt64"
            | "Int8"
            | "Int16"
            | "Int32"
            | "Int64"
            | "Float32"
            | "Float64"
    ) || type_name.starts_with("List(")
}
