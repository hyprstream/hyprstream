//! Schema-driven CLI command builder and dispatcher.
//!
//! Builds clap `Command` objects at runtime from `MethodSchema` metadata
//! (generated by hyprstream-rpc-derive from Cap'n Proto schemas) and
//! dispatches invocations to the appropriate service client's `call_method()`.

use anyhow::{bail, Result};
use clap::{Arg, ArgMatches, Command};
use ed25519_dalek::SigningKey;
use hyprstream_rpc::RequestIdentity;
use serde_json::Value;

use crate::services::generated::{
    inference_client, model_client, policy_client, registry_client,
};
use hyprstream_workers::generated::{worker_client, workflow_client};
use crate::services::{
    InferenceZmqClient, ModelZmqClient, PolicyClient, GenRegistryClient, WorkerZmqClient,
};

// ─────────────────────────────────────────────────────────────────────────────
// MethodSchemaLike trait — unifies per-module MethodSchema types
// ─────────────────────────────────────────────────────────────────────────────

/// Trait to abstract over the structurally identical but distinct `MethodSchema`
/// types generated by each service's proc macro invocation.
pub trait MethodSchemaLike {
    fn name(&self) -> &str;
    fn params(&self) -> &[impl ParamSchemaLike];
    fn is_scoped(&self) -> bool;
    fn scope_field(&self) -> &str;
    fn description(&self) -> &str;
    fn is_streaming(&self) -> bool;
    fn cli_hidden(&self) -> bool;
}

pub trait ParamSchemaLike {
    fn name(&self) -> &str;
    fn type_name(&self) -> &str;
    fn required(&self) -> bool;
    fn description(&self) -> &str;
}

/// Portable view of a method schema, extracted from any generated MethodSchema.
#[derive(Debug, Clone)]
pub struct MethodView {
    pub name: String,
    pub params: Vec<ParamView>,
    pub is_scoped: bool,
    pub scope_field: String,
    pub description: String,
    pub is_streaming: bool,
    pub cli_hidden: bool,
}

#[derive(Debug, Clone)]
pub struct ParamView {
    pub name: String,
    pub type_name: String,
    pub required: bool,
    pub description: String,
}

/// Extract a portable MethodView list from any generated module's schema_metadata.
/// Uses a macro since each module's MethodSchema is a distinct type.
macro_rules! extract_methods {
    ($schema_fn:expr) => {{
        let (_service_name, methods) = $schema_fn;
        methods
            .iter()
            .map(|m| MethodView {
                name: m.name.to_string(),
                params: m
                    .params
                    .iter()
                    .map(|p| ParamView {
                        name: p.name.to_string(),
                        type_name: p.type_name.to_string(),
                        required: p.required,
                        description: p.description.to_string(),
                    })
                    .collect(),
                is_scoped: m.is_scoped,
                scope_field: m.scope_field.to_string(),
                description: m.description.to_string(),
                is_streaming: m.is_streaming,
                cli_hidden: m.hidden,
            })
            .collect::<Vec<_>>()
    }};
}

macro_rules! extract_scoped_methods {
    ($schema_fn:expr) => {{
        let (service_name, scope_name, methods) = $schema_fn;
        let views: Vec<MethodView> = methods
            .iter()
            .map(|m| MethodView {
                name: m.name.to_string(),
                params: m
                    .params
                    .iter()
                    .map(|p| ParamView {
                        name: p.name.to_string(),
                        type_name: p.type_name.to_string(),
                        required: p.required,
                        description: p.description.to_string(),
                    })
                    .collect(),
                is_scoped: m.is_scoped,
                scope_field: m.scope_field.to_string(),
                description: m.description.to_string(),
                is_streaming: m.is_streaming,
                cli_hidden: m.hidden,
            })
            .collect();
        (service_name.to_string(), scope_name.to_string(), views)
    }};
}

// ─────────────────────────────────────────────────────────────────────────────
// Build clap Commands from schema metadata
// ─────────────────────────────────────────────────────────────────────────────

/// Build a clap `Command` for a service from its methods and scoped sub-services.
fn build_service_command(
    service_name: &str,
    methods: &[MethodView],
    scoped: &[(String, String, Vec<MethodView>)],
) -> Command {
    // Leak service_name to get 'static lifetime required by clap
    let name: &'static str = service_name.to_owned().leak();
    let mut cmd = Command::new(name)
        .about(format!("{} service commands", service_name));

    // Add top-level methods as subcommands (filtering cli_hidden and streaming)
    for method in methods {
        if method.cli_hidden || method.is_streaming {
            continue;
        }
        cmd = cmd.subcommand(build_method_command(method));
    }

    // Add scoped subcommands (e.g., "repo <id> <method>")
    for (_, scope_name, scope_methods) in scoped {
        let sn: &'static str = scope_name.clone().leak();
        let mut scope_cmd = Command::new(sn)
            .about(format!("{} scoped commands", scope_name))
            .arg(
                Arg::new("scope_id")
                    .required(true)
                    .help("Scope identifier (e.g., model name, repo ID)"),
            );

        for method in scope_methods {
            if method.cli_hidden || method.is_streaming {
                continue;
            }
            scope_cmd = scope_cmd.subcommand(build_method_command(method));
        }
        cmd = cmd.subcommand(scope_cmd);
    }

    cmd
}

/// Build a clap `Command` for a single method.
fn build_method_command(method: &MethodView) -> Command {
    // Convert snake_case method name to kebab-case for CLI
    // Leak the string to get a &'static str for clap's Str type
    let cli_name: &'static str = method.name.replace('_', "-").leak();
    let mut cmd = Command::new(cli_name);

    if !method.description.is_empty() {
        let desc: &'static str = method.description.clone().leak();
        cmd = cmd.about(desc);
    }

    for param in &method.params {
        let arg_name: &'static str = param.name.replace('_', "-").leak();
        let param_id: &'static str = param.name.clone().leak();
        let mut arg = Arg::new(param_id)
            .long(arg_name)
            .required(param.required);

        if !param.description.is_empty() {
            let help: &'static str = param.description.clone().leak();
            arg = arg.help(help);
        }

        cmd = cmd.arg(arg);
    }
    cmd
}

/// Build the `tool` command containing all schema-driven service subcommands.
///
/// Usage: `hyprstream tool <service> [scope <id>] <method> [--param value ...]`
pub fn build_tool_command() -> Command {
    let mut tool = Command::new("tool")
        .about("Direct RPC tool access (schema-driven, mirrors MCP tools)");

    // Registry service + scoped repo
    let registry_methods = extract_methods!(registry_client::schema_metadata());
    let repo_scoped = extract_scoped_methods!(registry_client::repo_schema_metadata());
    tool = tool.subcommand(build_service_command("registry", &registry_methods, &[repo_scoped]));

    // Model service + scoped ttt, peft, infer
    let model_methods = extract_methods!(model_client::schema_metadata());
    let ttt_scoped = extract_scoped_methods!(model_client::ttt_schema_metadata());
    let peft_scoped = extract_scoped_methods!(model_client::peft_schema_metadata());
    let infer_scoped = extract_scoped_methods!(model_client::infer_schema_metadata());
    tool = tool.subcommand(build_service_command(
        "model",
        &model_methods,
        &[ttt_scoped, peft_scoped, infer_scoped],
    ));

    // Inference service (standalone, no scoped)
    let inference_methods = extract_methods!(inference_client::schema_metadata());
    tool = tool.subcommand(build_service_command("inference", &inference_methods, &[]));

    // Policy service (standalone, no scoped)
    let policy_methods = extract_methods!(policy_client::schema_metadata());
    tool = tool.subcommand(build_service_command("policy", &policy_methods, &[]));

    // Worker service + 4 CRI-aligned scoped resources
    let worker_methods = extract_methods!(worker_client::schema_metadata());
    let runtime_scoped = extract_scoped_methods!(worker_client::runtime_schema_metadata());
    let sandbox_scoped = extract_scoped_methods!(worker_client::sandbox_schema_metadata());
    let container_scoped = extract_scoped_methods!(worker_client::container_schema_metadata());
    let image_scoped = extract_scoped_methods!(worker_client::image_schema_metadata());
    tool = tool.subcommand(build_service_command(
        "worker",
        &worker_methods,
        &[runtime_scoped, sandbox_scoped, container_scoped, image_scoped],
    ));

    // Workflow service (independent, flat — no scoped clients)
    let workflow_methods = extract_methods!(workflow_client::schema_metadata());
    tool = tool.subcommand(build_service_command("workflow", &workflow_methods, &[]));

    tool
}

/// Handle a `tool` subcommand by extracting the service name and delegating.
pub async fn handle_tool_command(matches: &ArgMatches, signing_key: SigningKey) -> Result<()> {
    let (service_name, service_matches) = matches
        .subcommand()
        .ok_or_else(|| {
            anyhow::anyhow!(
                "No service specified. Use: tool <registry|model|inference|policy|worker|workflow> ..."
            )
        })?;
    handle_schema_command(service_name, service_matches, signing_key).await
}

// ─────────────────────────────────────────────────────────────────────────────
// Dispatch schema commands
// ─────────────────────────────────────────────────────────────────────────────

/// Dispatch a schema-driven CLI command based on matched subcommands.
///
/// Returns Ok(()) after printing the result, or Err on failure.
pub async fn handle_schema_command(
    service_name: &str,
    matches: &ArgMatches,
    signing_key: SigningKey,
) -> Result<()> {
    // Determine which subcommand was invoked
    let (sub_name, sub_matches) = matches
        .subcommand()
        .ok_or_else(|| anyhow::anyhow!("No subcommand provided for {}", service_name))?;

    // Check if this is a scoped command (the subcommand has a scope_id positional arg)
    if let Some(scope_id) = sub_matches.get_one::<String>("scope_id") {
        // Scoped: e.g., "registry repo <id> <method>"
        let (method_name, method_matches) = sub_matches
            .subcommand()
            .ok_or_else(|| anyhow::anyhow!("No method provided for {} {}", service_name, sub_name))?;

        let method_snake = method_name.replace('-', "_");
        let methods = get_scoped_methods(service_name, sub_name);
        let args = matches_to_json(method_matches, &methods, &method_snake);

        let result = dispatch_scoped(
            service_name,
            sub_name,
            scope_id,
            &method_snake,
            &args,
            signing_key,
        )
        .await?;

        println!("{}", format_response(&result));
    } else {
        // Top-level: e.g., "registry list"
        let method_snake = sub_name.replace('-', "_");
        let methods = get_top_level_methods(service_name);
        let args = matches_to_json(sub_matches, &methods, &method_snake);

        let result = dispatch_top_level(service_name, &method_snake, &args, signing_key).await?;
        println!("{}", format_response(&result));
    }

    Ok(())
}

/// Dispatch a top-level (non-scoped) method call.
async fn dispatch_top_level(
    service: &str,
    method: &str,
    args: &Value,
    signing_key: SigningKey,
) -> Result<Value> {
    let identity = RequestIdentity::local();

    match service {
        "registry" => {
            let client: GenRegistryClient = crate::services::create_service_client(
                &hyprstream_rpc::registry::global().endpoint("registry", hyprstream_rpc::registry::SocketKind::Rep).to_zmq_string(),
                signing_key, identity,
            );
            client.call_method(method, args).await
        }
        "model" => {
            let client = ModelZmqClient::new(signing_key, identity);
            client.gen.call_method(method, args).await
        }
        "inference" => {
            let client = InferenceZmqClient::new(signing_key, identity);
            client.gen.call_method(method, args).await
        }
        "policy" => {
            let client = PolicyClient::new(signing_key, identity);
            client.call_method(method, args).await
        }
        "worker" => {
            bail!("Worker service has no top-level methods. Use: tool worker <runtime|sandbox|container|image> <node> <method>")
        }
        "workflow" => {
            bail!("Workflow service is not yet registered. Service factory needs to be implemented.")
        }
        _ => bail!("Unknown service: {}", service),
    }
}

/// Dispatch a scoped method call (e.g., registry repo <id> <method>).
async fn dispatch_scoped(
    service: &str,
    scope_name: &str,
    scope_id: &str,
    method: &str,
    args: &Value,
    signing_key: SigningKey,
) -> Result<Value> {
    let identity = RequestIdentity::local();

    match (service, scope_name) {
        ("registry", "repo") => {
            let client: GenRegistryClient = crate::services::create_service_client(
                &hyprstream_rpc::registry::global().endpoint("registry", hyprstream_rpc::registry::SocketKind::Rep).to_zmq_string(),
                signing_key, identity,
            );
            client.repo(scope_id).call_method(method, args).await
        }
        ("model", "ttt") => {
            let client = ModelZmqClient::new(signing_key, identity);
            client.gen.ttt(scope_id).call_method(method, args).await
        }
        ("model", "peft") => {
            let client = ModelZmqClient::new(signing_key, identity);
            client.gen.peft(scope_id).call_method(method, args).await
        }
        ("model", "infer") => {
            let client = ModelZmqClient::new(signing_key, identity);
            client.gen.infer(scope_id).call_method(method, args).await
        }
        ("worker", "runtime") => {
            let client = WorkerZmqClient::new(signing_key, identity);
            client.gen().runtime().call_method(method, args).await
        }
        ("worker", "sandbox") => {
            let client = WorkerZmqClient::new(signing_key, identity);
            client.gen().sandbox().call_method(method, args).await
        }
        ("worker", "container") => {
            let client = WorkerZmqClient::new(signing_key, identity);
            client.gen().container().call_method(method, args).await
        }
        ("worker", "image") => {
            let client = WorkerZmqClient::new(signing_key, identity);
            client.gen().image().call_method(method, args).await
        }
        _ => bail!("Unknown scoped service: {}.{}", service, scope_name),
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// ArgMatches → JSON conversion
// ─────────────────────────────────────────────────────────────────────────────

/// Get the top-level methods for a service (used for type conversion).
fn get_top_level_methods(service: &str) -> Vec<MethodView> {
    match service {
        "registry" => extract_methods!(registry_client::schema_metadata()),
        "model" => extract_methods!(model_client::schema_metadata()),
        "inference" => extract_methods!(inference_client::schema_metadata()),
        "policy" => extract_methods!(policy_client::schema_metadata()),
        "worker" => extract_methods!(worker_client::schema_metadata()),
        _ => Vec::new(),
    }
}

/// Get scoped methods for a service scope (used for type conversion).
fn get_scoped_methods(service: &str, scope: &str) -> Vec<MethodView> {
    match (service, scope) {
        ("registry", "repo") => extract_scoped_methods!(registry_client::repo_schema_metadata()).2,
        ("model", "ttt") => extract_scoped_methods!(model_client::ttt_schema_metadata()).2,
        ("model", "peft") => extract_scoped_methods!(model_client::peft_schema_metadata()).2,
        ("model", "infer") => extract_scoped_methods!(model_client::infer_schema_metadata()).2,
        ("worker", "runtime") => extract_scoped_methods!(worker_client::runtime_schema_metadata()).2,
        ("worker", "sandbox") => extract_scoped_methods!(worker_client::sandbox_schema_metadata()).2,
        ("worker", "container") => extract_scoped_methods!(worker_client::container_schema_metadata()).2,
        ("worker", "image") => extract_scoped_methods!(worker_client::image_schema_metadata()).2,
        _ => Vec::new(),
    }
}

/// Convert clap `ArgMatches` into a JSON object, using MethodView params for type coercion.
fn matches_to_json(matches: &ArgMatches, methods: &[MethodView], method_name: &str) -> Value {
    let method = methods.iter().find(|m| m.name == method_name);
    let mut map = serde_json::Map::new();

    if let Some(method) = method {
        for param in &method.params {
            if let Some(val) = matches.get_one::<String>(&param.name) {
                let json_val = coerce_value(val, &param.type_name);
                map.insert(param.name.clone(), json_val);
            }
        }
    } else {
        // Fallback: extract all string args
        for id in matches.ids() {
            if let Some(val) = matches.get_one::<String>(id.as_str()) {
                map.insert(id.to_string(), Value::String(val.clone()));
            }
        }
    }

    Value::Object(map)
}

/// Coerce a string value to the appropriate JSON type based on Cap'n Proto type name.
fn coerce_value(s: &str, type_name: &str) -> Value {
    match type_name {
        "Bool" => Value::Bool(s.parse().unwrap_or(false)),
        "UInt8" | "UInt16" | "UInt32" | "UInt64" => {
            s.parse::<u64>().map(Value::from).unwrap_or(Value::String(s.to_string()))
        }
        "Int8" | "Int16" | "Int32" | "Int64" => {
            s.parse::<i64>().map(Value::from).unwrap_or(Value::String(s.to_string()))
        }
        "Float32" | "Float64" => {
            s.parse::<f64>().map(Value::from).unwrap_or(Value::String(s.to_string()))
        }
        _ if type_name.starts_with("List(") => {
            // Split comma-separated values into a JSON array
            Value::Array(s.split(',').map(|v| Value::String(v.trim().to_string())).collect())
        }
        _ => Value::String(s.to_string()),
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Response formatting
// ─────────────────────────────────────────────────────────────────────────────

/// Format a JSON value as a human-readable string for CLI output.
pub fn format_response(value: &Value) -> String {
    match value {
        Value::Null => "OK".to_string(),
        Value::String(s) => s.clone(),
        Value::Bool(b) => b.to_string(),
        Value::Number(n) => n.to_string(),
        Value::Array(arr) if arr.is_empty() => "(empty)".to_string(),
        Value::Array(arr) => format_array_as_table(arr),
        Value::Object(obj) if obj.is_empty() => "OK".to_string(),
        Value::Object(obj) => format_object_as_kv(obj),
    }
}

/// Format a JSON array as an aligned table.
fn format_array_as_table(arr: &[Value]) -> String {
    // If array of objects, format as columnar table
    if let Some(Value::Object(first)) = arr.first() {
        let keys: Vec<String> = first.keys().cloned().collect();

        // Calculate column widths
        let mut widths: Vec<usize> = keys.iter().map(|k| k.len()).collect();
        for item in arr {
            if let Value::Object(obj) = item {
                for (i, key) in keys.iter().enumerate() {
                    let val_len = format_cell(obj.get(key)).len();
                    if val_len > widths[i] {
                        widths[i] = val_len;
                    }
                }
            }
        }

        let mut out = String::new();

        // Header
        for (i, key) in keys.iter().enumerate() {
            if i > 0 {
                out.push_str("  ");
            }
            out.push_str(&format!("{:<width$}", key.to_uppercase(), width = widths[i]));
        }
        out.push('\n');

        // Separator
        for (i, width) in widths.iter().enumerate() {
            if i > 0 {
                out.push_str("  ");
            }
            for _ in 0..*width {
                out.push('-');
            }
        }
        out.push('\n');

        // Rows
        for item in arr {
            if let Value::Object(obj) = item {
                for (i, key) in keys.iter().enumerate() {
                    if i > 0 {
                        out.push_str("  ");
                    }
                    out.push_str(&format!(
                        "{:<width$}",
                        format_cell(obj.get(key)),
                        width = widths[i]
                    ));
                }
                out.push('\n');
            }
        }

        out.trim_end().to_string()
    } else {
        // Array of primitives
        arr.iter()
            .map(|v| match v {
                Value::String(s) => s.clone(),
                other => other.to_string(),
            })
            .collect::<Vec<_>>()
            .join("\n")
    }
}

/// Format a JSON object as aligned key-value pairs.
fn format_object_as_kv(obj: &serde_json::Map<String, Value>) -> String {
    if obj.is_empty() {
        return "OK".to_string();
    }

    let max_key_len = obj.keys().map(|k| k.len()).max().unwrap_or(0);
    let mut out = String::new();

    for (key, value) in obj {
        out.push_str(&format!(
            "{:<width$}  {}\n",
            key,
            format_cell(Some(value)),
            width = max_key_len
        ));
    }

    out.trim_end().to_string()
}

/// Format a single cell value for table output.
fn format_cell(value: Option<&Value>) -> String {
    match value {
        None => "-".to_string(),
        Some(Value::Null) => "-".to_string(),
        Some(Value::String(s)) => s.clone(),
        Some(Value::Bool(b)) => b.to_string(),
        Some(Value::Number(n)) => n.to_string(),
        Some(Value::Array(arr)) => {
            let items: Vec<String> = arr
                .iter()
                .map(|v| match v {
                    Value::String(s) => s.clone(),
                    other => other.to_string(),
                })
                .collect();
            items.join(", ")
        }
        Some(Value::Object(obj)) => {
            serde_json::to_string(obj).unwrap_or_else(|_| "{}".to_string())
        }
    }
}


