// CLI module — prints to stdout for user interaction
#![allow(clippy::print_stdout, clippy::print_stderr)]
//! Schema-driven CLI command builder and dispatcher.
//!
//! Builds clap `Command` objects at runtime from `MethodSchema` metadata
//! (generated by hyprstream-rpc-derive from Cap'n Proto schemas) and
//! dispatches invocations to the appropriate service client's `call_method()`.

use anyhow::{bail, Result};
use clap::{Arg, ArgMatches, Command};
use ed25519_dalek::SigningKey;
use hyprstream_rpc::RequestIdentity;
use hyprstream_rpc::service::metadata::ScopedClientTreeNode;
use serde_json::Value;

use crate::services::generated::{
    inference_client, model_client, policy_client, registry_client,
};
use hyprstream_workers::generated::{worker_client, workflow_client};
use crate::services::{
    InferenceZmqClient, ModelZmqClient, PolicyClient, GenRegistryClient, WorkerZmqClient,
};

// ─────────────────────────────────────────────────────────────────────────────
// MethodSchemaLike trait — unifies per-module MethodSchema types
// ─────────────────────────────────────────────────────────────────────────────

/// Trait to abstract over the structurally identical but distinct `MethodSchema`
/// types generated by each service's proc macro invocation.
pub trait MethodSchemaLike {
    fn name(&self) -> &str;
    fn params(&self) -> &[impl ParamSchemaLike];
    fn is_scoped(&self) -> bool;
    fn scope_field(&self) -> &str;
    fn description(&self) -> &str;
    fn is_streaming(&self) -> bool;
    fn cli_hidden(&self) -> bool;
}

pub trait ParamSchemaLike {
    fn name(&self) -> &str;
    fn type_name(&self) -> &str;
    fn required(&self) -> bool;
    fn description(&self) -> &str;
}

/// Portable view of a method schema, extracted from any generated MethodSchema.
#[derive(Debug, Clone)]
pub struct MethodView {
    pub name: String,
    pub params: Vec<ParamView>,
    pub is_scoped: bool,
    pub scope_field: String,
    pub description: String,
    pub is_streaming: bool,
    pub cli_hidden: bool,
}

#[derive(Debug, Clone)]
pub struct ParamView {
    pub name: String,
    pub type_name: String,
    pub required: bool,
    pub description: String,
}

/// Extract a portable MethodView list from any generated module's schema_metadata.
/// Uses a macro since each module's MethodSchema is a distinct type.
macro_rules! extract_methods {
    ($schema_fn:expr) => {{
        let (_service_name, methods) = $schema_fn;
        methods_to_views(methods)
    }};
}

/// Convert a slice of MethodMeta into MethodView values.
fn methods_to_views(methods: &[hyprstream_rpc::service::metadata::MethodMeta]) -> Vec<MethodView> {
    methods
        .iter()
        .map(|m| MethodView {
            name: m.name.to_string(),
            params: m
                .params
                .iter()
                .map(|p| ParamView {
                    name: p.name.to_string(),
                    type_name: p.type_name.to_string(),
                    required: p.required,
                    description: p.description.to_string(),
                })
                .collect(),
            is_scoped: m.is_scoped,
            scope_field: m.scope_field.to_string(),
            description: m.description.to_string(),
            is_streaming: m.is_streaming,
            cli_hidden: m.hidden,
        })
        .collect()
}

/// Convert scoped metadata (service, scope, methods) into MethodView values.
fn scoped_methods_to_views(
    metadata_fn: hyprstream_rpc::service::metadata::ScopedSchemaMetadataFn,
) -> Vec<MethodView> {
    let (_service_name, _scope_name, methods) = metadata_fn();
    methods_to_views(methods)
}

// ─────────────────────────────────────────────────────────────────────────────
// Build clap Commands from schema metadata
// ─────────────────────────────────────────────────────────────────────────────

/// Build a clap `Command` for a service from its methods and scoped client tree.
fn build_service_command(
    service_name: &str,
    methods: &[MethodView],
    tree: &'static [ScopedClientTreeNode],
) -> Command {
    // Leak service_name to get 'static lifetime required by clap
    let name: &'static str = service_name.to_owned().leak();
    let mut cmd = Command::new(name)
        .about(format!("{} service commands", service_name))
        .arg_required_else_help(true);

    // Add top-level methods as subcommands (filtering cli_hidden and streaming)
    for method in methods {
        if method.cli_hidden || method.is_streaming {
            continue;
        }
        cmd = cmd.subcommand(build_method_command(method));
    }

    // Add scoped subcommands from tree (recursive)
    for node in tree {
        cmd = cmd.subcommand(build_scoped_command_from_node(node));
    }

    cmd
}

/// Recursively build a scoped command from a tree node.
fn build_scoped_command_from_node(node: &ScopedClientTreeNode) -> Command {
    let sn: &'static str = node.scope_name;
    let methods = scoped_methods_to_views(node.metadata_fn);

    let mut cmd = Command::new(sn)
        .about(format!("{} scoped commands", node.scope_name))
        .subcommand_required(true)
        .arg_required_else_help(true);

    // Only add scope_id positional arg if there's a scope field
    if !node.scope_field.is_empty() {
        cmd = cmd.arg(
            Arg::new("scope_id")
                .required(true)
                .help("Scope identifier (e.g., model name, repo ID)"),
        );
    }

    for method in &methods {
        if method.cli_hidden || method.is_streaming {
            continue;
        }
        cmd = cmd.subcommand(build_method_command(method));
    }

    // Recursively add nested scoped commands
    for nested in node.nested {
        cmd = cmd.subcommand(build_scoped_command_from_node(nested));
    }

    cmd
}

/// Build a clap `Command` for a single method.
fn build_method_command(method: &MethodView) -> Command {
    // Convert snake_case method name to kebab-case for CLI
    // Leak the string to get a &'static str for clap's Str type
    let cli_name: &'static str = method.name.replace('_', "-").leak();
    let mut cmd = Command::new(cli_name);

    if !method.description.is_empty() {
        let desc: &'static str = method.description.clone().leak();
        cmd = cmd.about(desc);
    }

    for param in &method.params {
        let arg_name: &'static str = param.name.replace('_', "-").leak();
        let param_id: &'static str = param.name.clone().leak();
        let mut arg = Arg::new(param_id)
            .long(arg_name)
            .required(param.required);

        if !param.description.is_empty() {
            let help: &'static str = param.description.clone().leak();
            arg = arg.help(help);
        }

        cmd = cmd.arg(arg);
    }
    cmd
}

/// Build the `tool` command containing all schema-driven service subcommands.
///
/// Usage: `hyprstream tool <service> [scope <id>] <method> [--param value ...]`
pub fn build_tool_command() -> Command {
    let mut tool = Command::new("tool")
        .about("Direct RPC tool access (schema-driven, mirrors MCP tools)");

    // Registry service
    let registry_methods = extract_methods!(registry_client::schema_metadata());
    let registry_tree = registry_client::scoped_client_tree();
    tool = tool.subcommand(build_service_command("registry", &registry_methods, registry_tree));

    // Model service
    let model_methods = extract_methods!(model_client::schema_metadata());
    let model_tree = model_client::scoped_client_tree();
    tool = tool.subcommand(build_service_command("model", &model_methods, model_tree));

    // Inference service (standalone, no scoped)
    let inference_methods = extract_methods!(inference_client::schema_metadata());
    let inference_tree = inference_client::scoped_client_tree();
    tool = tool.subcommand(build_service_command("inference", &inference_methods, inference_tree));

    // Policy service (standalone, no scoped)
    let policy_methods = extract_methods!(policy_client::schema_metadata());
    let policy_tree = policy_client::scoped_client_tree();
    tool = tool.subcommand(build_service_command("policy", &policy_methods, policy_tree));

    // Worker service + CRI-aligned scoped resources
    let worker_methods = extract_methods!(worker_client::schema_metadata());
    let worker_tree = worker_client::scoped_client_tree();
    tool = tool.subcommand(build_service_command("worker", &worker_methods, worker_tree));

    // Workflow service
    let workflow_methods = extract_methods!(workflow_client::schema_metadata());
    let workflow_tree = workflow_client::scoped_client_tree();
    tool = tool.subcommand(build_service_command("workflow", &workflow_methods, workflow_tree));

    tool
}

/// Handle a `tool` subcommand by extracting the service name and delegating.
pub async fn handle_tool_command(matches: &ArgMatches, signing_key: SigningKey) -> Result<()> {
    let (service_name, service_matches) = matches
        .subcommand()
        .ok_or_else(|| {
            anyhow::anyhow!(
                "No service specified. Use: tool <registry|model|inference|policy|worker|workflow> ..."
            )
        })?;
    handle_schema_command(service_name, service_matches, signing_key).await
}

// ─────────────────────────────────────────────────────────────────────────────
// Dispatch schema commands
// ─────────────────────────────────────────────────────────────────────────────

/// Get the scoped client tree for a service.
fn get_service_tree(service: &str) -> &'static [ScopedClientTreeNode] {
    match service {
        "registry" => registry_client::scoped_client_tree(),
        "model" => model_client::scoped_client_tree(),
        "inference" => inference_client::scoped_client_tree(),
        "policy" => policy_client::scoped_client_tree(),
        "worker" => worker_client::scoped_client_tree(),
        "workflow" => workflow_client::scoped_client_tree(),
        _ => &[],
    }
}

/// Dispatch a schema-driven CLI command based on matched subcommands.
///
/// Supports recursive scoped commands (e.g., `registry repo <id> worktree <name> <method>`).
pub async fn handle_schema_command(
    service_name: &str,
    matches: &ArgMatches,
    signing_key: SigningKey,
) -> Result<()> {
    // Determine which subcommand was invoked
    let (sub_name, sub_matches) = matches
        .subcommand()
        .ok_or_else(|| anyhow::anyhow!("No subcommand provided for {}", service_name))?;

    let tree = get_service_tree(service_name);

    // Check if this is a scoped command by looking up the sub_name in the tree
    if let Some(node) = tree.iter().find(|n| n.scope_name == sub_name) {
        // Scoped: recursively walk scope chain
        let mut scope_chain: Vec<(&str, &str)> = Vec::new();
        let mut current_node = node;
        let mut current_matches = sub_matches;

        // Collect scope_id if this node has scope fields
        if !current_node.scope_field.is_empty() {
            let scope_id = current_matches
                .get_one::<String>("scope_id")
                .ok_or_else(|| anyhow::anyhow!("Missing scope ID for {}", sub_name))?;
            scope_chain.push((current_node.scope_name, scope_id.as_str()));
        } else {
            scope_chain.push((current_node.scope_name, ""));
        }

        loop {
            let (next_name, next_matches) = current_matches
                .subcommand()
                .ok_or_else(|| anyhow::anyhow!("No method provided"))?;

            // Check if next_name is a nested scope
            if let Some(nested_node) = current_node.nested.iter().find(|n| n.scope_name == next_name) {
                // It's a deeper scope level
                if !nested_node.scope_field.is_empty() {
                    let nested_id = next_matches
                        .get_one::<String>("scope_id")
                        .ok_or_else(|| anyhow::anyhow!("Missing scope ID for {}", next_name))?;
                    scope_chain.push((nested_node.scope_name, nested_id.as_str()));
                } else {
                    scope_chain.push((nested_node.scope_name, ""));
                }
                current_node = nested_node;
                current_matches = next_matches;
            } else {
                // Reached the method — dispatch
                let method_snake = next_name.replace('-', "_");
                let methods = find_methods_in_tree(tree, &scope_chain);
                let args = matches_to_json(next_matches, &methods, &method_snake);

                let result = dispatch_scoped_dynamic(
                    service_name, &scope_chain, &method_snake, &args, signing_key,
                )
                .await?;

                println!("{}", format_response(&result));
                break;
            }
        }
    } else {
        // Top-level: e.g., "registry list"
        let method_snake = sub_name.replace('-', "_");
        let methods = get_top_level_methods(service_name);
        let args = matches_to_json(sub_matches, &methods, &method_snake);

        let result = dispatch_top_level(service_name, &method_snake, &args, signing_key).await?;
        println!("{}", format_response(&result));
    }

    Ok(())
}

/// Dispatch a top-level (non-scoped) method call.
async fn dispatch_top_level(
    service: &str,
    method: &str,
    args: &Value,
    signing_key: SigningKey,
) -> Result<Value> {
    let identity = RequestIdentity::local();

    match service {
        "registry" => {
            let client: GenRegistryClient = crate::services::create_service_client(
                &hyprstream_rpc::registry::global().endpoint("registry", hyprstream_rpc::registry::SocketKind::Rep).to_zmq_string(),
                signing_key, identity,
            );
            client.call_method(method, args).await
        }
        "model" => {
            let client = ModelZmqClient::new(signing_key, identity);
            client.gen.call_method(method, args).await
        }
        "inference" => {
            let client = InferenceZmqClient::new(signing_key, identity);
            client.gen.call_method(method, args).await
        }
        "policy" => {
            let client = PolicyClient::new(signing_key, identity);
            client.call_method(method, args).await
        }
        "worker" => {
            bail!("Worker service has no top-level methods. Use: tool worker <runtime|sandbox|container|image> <method>")
        }
        "workflow" => {
            bail!("Workflow service is not yet registered. Service factory needs to be implemented.")
        }
        _ => bail!("Unknown service: {}", service),
    }
}

/// Dispatch a scoped method call via `call_scoped_method` through the scope chain.
async fn dispatch_scoped_dynamic(
    service: &str,
    scope_chain: &[(&str, &str)],
    method: &str,
    args: &Value,
    signing_key: SigningKey,
) -> Result<Value> {
    let identity = RequestIdentity::local();

    match service {
        "registry" => {
            let client: GenRegistryClient = crate::services::create_service_client(
                &hyprstream_rpc::registry::global().endpoint("registry", hyprstream_rpc::registry::SocketKind::Rep).to_zmq_string(),
                signing_key, identity,
            );
            client.call_scoped_method(scope_chain, method, args).await
        }
        "model" => {
            let client = ModelZmqClient::new(signing_key, identity);
            client.gen.call_scoped_method(scope_chain, method, args).await
        }
        "worker" => {
            let client = WorkerZmqClient::new(signing_key, identity);
            client.gen().call_scoped_method(scope_chain, method, args).await
        }
        _ => bail!("Service '{}' has no scoped methods", service),
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// ArgMatches → JSON conversion
// ─────────────────────────────────────────────────────────────────────────────

/// Get the top-level methods for a service (used for type conversion).
fn get_top_level_methods(service: &str) -> Vec<MethodView> {
    match service {
        "registry" => extract_methods!(registry_client::schema_metadata()),
        "model" => extract_methods!(model_client::schema_metadata()),
        "inference" => extract_methods!(inference_client::schema_metadata()),
        "policy" => extract_methods!(policy_client::schema_metadata()),
        "worker" => extract_methods!(worker_client::schema_metadata()),
        _ => Vec::new(),
    }
}

/// Find methods for a scope chain by walking the tree.
fn find_methods_in_tree(
    tree: &[ScopedClientTreeNode],
    scope_chain: &[(&str, &str)],
) -> Vec<MethodView> {
    if scope_chain.is_empty() {
        return vec![];
    }
    for node in tree {
        if node.scope_name == scope_chain[0].0 {
            if scope_chain.len() == 1 {
                return scoped_methods_to_views(node.metadata_fn);
            }
            return find_methods_in_tree(node.nested, &scope_chain[1..]);
        }
    }
    vec![]
}

/// Convert clap `ArgMatches` into a JSON object, using MethodView params for type coercion.
fn matches_to_json(matches: &ArgMatches, methods: &[MethodView], method_name: &str) -> Value {
    let method = methods.iter().find(|m| m.name == method_name);
    let mut map = serde_json::Map::new();

    if let Some(method) = method {
        for param in &method.params {
            if let Some(val) = matches.get_one::<String>(&param.name) {
                let json_val = coerce_value(val, &param.type_name);
                map.insert(param.name.clone(), json_val);
            }
        }
    } else {
        // Fallback: extract all string args
        for id in matches.ids() {
            if let Some(val) = matches.get_one::<String>(id.as_str()) {
                map.insert(id.to_string(), Value::String(val.clone()));
            }
        }
    }

    Value::Object(map)
}

/// Coerce a string value to the appropriate JSON type based on Cap'n Proto type name.
fn coerce_value(s: &str, type_name: &str) -> Value {
    match type_name {
        "Bool" => Value::Bool(s.parse().unwrap_or(false)),
        "UInt8" | "UInt16" | "UInt32" | "UInt64" => {
            s.parse::<u64>().map(Value::from).unwrap_or(Value::String(s.to_string()))
        }
        "Int8" | "Int16" | "Int32" | "Int64" => {
            s.parse::<i64>().map(Value::from).unwrap_or(Value::String(s.to_string()))
        }
        "Float32" | "Float64" => {
            s.parse::<f64>().map(Value::from).unwrap_or(Value::String(s.to_string()))
        }
        _ if type_name.starts_with("List(") => {
            // Split comma-separated values into a JSON array
            Value::Array(s.split(',').map(|v| Value::String(v.trim().to_string())).collect())
        }
        _ => Value::String(s.to_string()),
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Response formatting
// ─────────────────────────────────────────────────────────────────────────────

/// Format a JSON value as a human-readable string for CLI output.
pub fn format_response(value: &Value) -> String {
    match value {
        Value::Null => "OK".to_string(),
        Value::String(s) => s.clone(),
        Value::Bool(b) => b.to_string(),
        Value::Number(n) => n.to_string(),
        Value::Array(arr) if arr.is_empty() => "(empty)".to_string(),
        Value::Array(arr) => format_array_as_table(arr),
        Value::Object(obj) if obj.is_empty() => "OK".to_string(),
        Value::Object(obj) => format_object_as_kv(obj),
    }
}

/// Format a JSON array as an aligned table.
fn format_array_as_table(arr: &[Value]) -> String {
    // If array of objects, format as columnar table
    if let Some(Value::Object(first)) = arr.first() {
        let keys: Vec<String> = first.keys().cloned().collect();

        // Calculate column widths
        let mut widths: Vec<usize> = keys.iter().map(|k| k.len()).collect();
        for item in arr {
            if let Value::Object(obj) = item {
                for (i, key) in keys.iter().enumerate() {
                    let val_len = format_cell(obj.get(key)).len();
                    if val_len > widths[i] {
                        widths[i] = val_len;
                    }
                }
            }
        }

        let mut out = String::new();

        // Header
        for (i, key) in keys.iter().enumerate() {
            if i > 0 {
                out.push_str("  ");
            }
            out.push_str(&format!("{:<width$}", key.to_uppercase(), width = widths[i]));
        }
        out.push('\n');

        // Separator
        for (i, width) in widths.iter().enumerate() {
            if i > 0 {
                out.push_str("  ");
            }
            for _ in 0..*width {
                out.push('-');
            }
        }
        out.push('\n');

        // Rows
        for item in arr {
            if let Value::Object(obj) = item {
                for (i, key) in keys.iter().enumerate() {
                    if i > 0 {
                        out.push_str("  ");
                    }
                    out.push_str(&format!(
                        "{:<width$}",
                        format_cell(obj.get(key)),
                        width = widths[i]
                    ));
                }
                out.push('\n');
            }
        }

        out.trim_end().to_string()
    } else {
        // Array of primitives
        arr.iter()
            .map(|v| match v {
                Value::String(s) => s.clone(),
                other => other.to_string(),
            })
            .collect::<Vec<_>>()
            .join("\n")
    }
}

/// Format a JSON object as aligned key-value pairs.
fn format_object_as_kv(obj: &serde_json::Map<String, Value>) -> String {
    if obj.is_empty() {
        return "OK".to_string();
    }

    let max_key_len = obj.keys().map(|k| k.len()).max().unwrap_or(0);
    let mut out = String::new();

    for (key, value) in obj {
        out.push_str(&format!(
            "{:<width$}  {}\n",
            key,
            format_cell(Some(value)),
            width = max_key_len
        ));
    }

    out.trim_end().to_string()
}

/// Format a single cell value for table output.
fn format_cell(value: Option<&Value>) -> String {
    match value {
        None | Some(Value::Null) => "-".to_string(),
        Some(Value::String(s)) => s.clone(),
        Some(Value::Bool(b)) => b.to_string(),
        Some(Value::Number(n)) => n.to_string(),
        Some(Value::Array(arr)) => {
            let items: Vec<String> = arr
                .iter()
                .map(|v| match v {
                    Value::String(s) => s.clone(),
                    other => other.to_string(),
                })
                .collect();
            items.join(", ")
        }
        Some(Value::Object(obj)) => {
            serde_json::to_string(obj).unwrap_or_else(|_| "{}".to_string())
        }
    }
}
